# Задание 5

## 5.2 Анализ

Для текущей системы точно необходимо внедрять CDN для статичного контента, так как сейчас подгрузка статики может занимать достаточно много времени. Кэширование так же можно и, возможно, нужно внедрять, но для этого нужно:
1. Проанализировать запросы к бд, понять, какое количество запросов повторяется и как часто происходят селекты. Возможно, проблема в оптимизации бд
2. Проанализировать запросы на api, посмотреть, какие из них можно закэшировать и есть ли смысл в этом
К моменту решения данного вопроса у нас уже должны быть все инструменты для анализа нашей системы

## 5.3 Мотивация

Кэширование, если оно необходимо, позволит избежать ненужной нагрузки на систему со стороны потребителей сервисов для однотипных запросов. Это могут быть запросы на каталог товаров или статус заказа (хотя и такая реализация была бы странной). Снижение нагрузки произойдёт не только на наши инстансы сервисов, но и на базу данных. К тому же со стороны клиента не будет негатива по долгой загрузке контента.

## 5.4 Предлагаемое решение

1. Будем использовать кэширование статики (CDN)
2. При наличии необходимости добавляем кэширование через Redis (на схеме не отражено, так как не факт, что должно быть. Но, по факту, просто стрелка от api gateway до Redis, а Redis уже при инвалидации должен забирать данные из каждого сервиса при необходимости)
3. Так же добавляем клиентское кэширование для основной статики
Таким образом мы совмещаем и клиентское кэширование и серверное. Это позволит нам закрыть все потребности по производительности для пользователя

Стратегия - Cache-Aside. Самая простая реализация, которая даёт нам все бенефиты кэширования, к тому же у нас нет необходимости в том, чтобы данные были всегда актуальными. Если пользователь не увидит новый элемент в каталоге или статус заказа будет устаревшим, то это не вызовет негатива у пользователя, ведь инвалидация кэша происходит сравнительно (для пользователя) часто, так что он не заметит разницы

## 5.5 Диаграмма последовательностей

@startuml
actor "Пользователь" as User
participant "Internet Shop (SPA)" as SPA
participant "API Gateway" as Gateway
participant "Redis" as Redis
participant "Shop API" as ShopAPI
database "Shop DB" as DB

== Happy Path: Чтение списка заказов (кэш актуален) ==

User -> SPA: Запрос списка заказов
SPA -> Gateway: GET /orders
Gateway -> Redis: Запрос кэша (GET orders)
Redis --> Gateway: Возвращает кэшированные данные
Gateway --> SPA: Данные заказов
SPA --> User: Отображение заказов

== Обновление статуса заказа ==

User -> SPA: Изменение статуса заказа
SPA -> Gateway: PATCH /orders/{id}/status
Gateway -> ShopAPI: PATCH /orders/{id}/status
ShopAPI -> DB: UPDATE status WHERE order_id = {id}
DB --> ShopAPI: Подтверждение
ShopAPI --> Gateway: 200 OK
Gateway --> SPA: Успешное обновление
SPA --> User: Статус обновлен

ShopAPI -> Redis: Инвалидация кэша (DEL orders)

== Сценарий с устаревшим кэшем ==

User -> SPA: Запрос списка заказов
SPA -> Gateway: GET /orders
Gateway -> Redis: Запрос кэша (GET orders)
Redis --> Gateway: Кэш отсутствует/устарел
Gateway -> ShopAPI: GET /orders
ShopAPI -> DB: SELECT * FROM orders
DB --> ShopAPI: Данные заказов
ShopAPI --> Gateway: Данные заказов
Gateway -> Redis: Кэширование (SET orders)
Gateway --> SPA: Данные заказов
SPA --> User: Отображение заказов
@enduml

## 5.6 Предлагаемое решение

Как уже отмечено на диаграмме выше, мы используем стратегию инвалидации по событию. Т.е. при обновлении статуса заказа мы должны почистить для этого клиента все данные о его заказах. Однако, это не очень хороший способ инвалидации в случае, если мы отображаем каталог товаров. Таким образом, в нашей архитектуре лучше всего подойдёт гибридный подход: для определённых запросов лучше всего использовать TTl стратегию, но для тех, где важно отображать актуальную информацию после изменения данных, лучше использовать стратегию инвалидации по событию