# Задание 4

## 4.2 Логи

В моей практике не было моментов, когда вставал вопрос логирования и его необходимости. Для меня правило хорошего тона - всегда логировать основные моменты. Если у сервиса есть api, который по результату выполнения должен заполнить какие-то данные в бд, то я предложу залогировать весь путь прохождения этого процесса. Т.е. должны быть логи сервиса (уровень контроллера), должны быть логи уровня сервиса и логи репозитория, если это необходимо. Такой подход может не подойти, если у нас очень большое кол-во запросов и мы быстро забиваем физическую память этими логами. Тогда можно сделать логирование сервиса (уровень котроллера) для INFO и остальные части только на FAIL уровень. Но, кмк, можно попробовать залогировать все части.
С т.з. использования ELK, мы можем вполне хорошо справляться с различными багами и недоработками просто анализируя логи. По моему опыту, ELK хорошо работает с большим кол-вом логов, поэтому проблем возникнуть не должно
Однако, важный аспект состоит в том, что на каждом уровне и на каждой системе, нам нужно придерживаться шаблону по логированию, чтобы, если нам необходимо будет найти тот или иной момент, мы могли не лезть в код, а сразу понять, как и в каком формате мы сможем найти логи в ELK
Уровни FAIL и WARN так же должны будут быть использованы на усмотрение разработчиками.

## 4.3 Мотивация

Трейсинг уже был описан ранее, не вижу смысла дублировать информацию. 
Логирование важно для разработчиков при разборе дефектов. Трейсер - более тяжёлый инструмент, который, к тому же, можно включить на какой-то процент использования. Логи же помогают детектировать точечкую проблему на уровне кода. Такая реализация кода необходима для быстрой диагностики в случае проблем, это важная часть разработки любого приложения
Тех. метрики
1. RPS (так же и бизнес метрика)
2. Ошибки записи в бд
3. Таймауты
4. Ошибки 4xx, 5xx, их квантили
Бизнес метрики
5. Распределение заявок по времени
6. Время просчёта изделия

## 4.4 Предлагаемое решение

Решение зависит от разработчиков, они должны понимать, какая реализация будет лучше лежать на их коде, т.к. не все решения могут быть совместимы с текущим стеком технологий, а менять кодовую базу из-за того, что выбрано определенное решение в части логов неправильно. Доработать нужно будет все бэкенд системы на логирование, если такового нет в текущий момент. Если есть, то посмотреть соответствию единому шаблону логирования. Хранение логов должно быть таким, чтобы позволяло разобрать инциденты с закрытыми заявками в течение какого-то периода. С т.з. конкретного времени так же будет неправильно сейчас выставлять какие-то пороговые значения, так как нам неизвестно то, сколько могут максимально (по времени) обрабатываться заявки.
На каждую систему должен быть свой индекс для удобства просмотра. Так как у нас асинхрон, то и логирование всего в одну кучу не имеет смысла, так как мы всё равно не можем гарантировать последовательность выполнения функционала. 
Политика перс. данных и т.д.: в логах не должно быть информации, которая могла бы относиться напрямую к клиенту. Вместо этого используем идентификаторы, статусы и т.д.

## 4.5 Алёртинг

С использованием решений на основе RED метода для API я не вижу смысла в повторном алёртинге, но уже на уровне логов. Логи должны быть частью системы, которая помогает решать проблемы в коде, а не проблемы внешнего характера, для этого есть другие типы систем и алёртинга
